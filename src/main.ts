import { app, BrowserWindow, dialog } from 'electron';
import { ipcMain } from 'electron-typescript-ipc';
import { IEntryOrder, IEvidAPI, FileDialogResult } from './ui/api';
import * as devOnly from "electron-devtools-installer";
import * as settings from "electron-settings";
import { EntryType, MonthId } from './model';
import { createFakeDb, CurrentDatabase, openDb } from './CurrentDatabase';

// Conditionally include the dev tools installer to load React Dev Tools
let devTools: typeof devOnly;  
const isDev = !app.isPackaged;
if (isDev) {  
  devTools = require("electron-devtools-installer");
}

// This allows TypeScript to pick up the magic constant that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;

declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;


declare const PRINT_WINDOW_WEBPACK_ENTRY: string;

declare const PRINT_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) { // eslint-disable-line global-require
  app.quit();
}

type WindowSettings = {
  height?: number,
  width?: number,
  maximized?: boolean
}

let currentDatabase: CurrentDatabase = createFakeDb();

const monthReportPrintOptions: Electron.WebContentsPrintOptions = {
  margins: {
    marginType: "printableArea"
  },
  printBackground: false,
  landscape: false,
  pageSize: "A4"
};

const yearReportPrintOptions: Electron.WebContentsPrintOptions = {
  margins: {
    marginType: "printableArea"
  },
  printBackground: false,
  landscape: true,
  pageSize: "A4"
};

function printReport(type: "year" | "month", yearId: number, monthId?: MonthId) {
  const printWindow = new BrowserWindow({
    height: 1200,
    width: 1600,
    show: false,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: PRINT_WINDOW_PRELOAD_WEBPACK_ENTRY
    },
  });

  console.log("printReport(" + type + ")");

  ipcMain.removeHandler<IEvidAPI>("contentRendered");
  ipcMain.handle<IEvidAPI>("contentRendered", async () => {
    printWindow.webContents.print((type == "year" ? yearReportPrintOptions : monthReportPrintOptions), () => printWindow.close());
  });

  printWindow.on("close", () => {
    ipcMain.removeHandler<IEvidAPI>("contentRendered");
  });

  let queryString = "?type=" + type + "&yearId=" + yearId;
  if (type == "month") {
    queryString += "&monthId=" + monthId;
  }

  // and load the index.html of the app.
  printWindow.loadURL(PRINT_WINDOW_WEBPACK_ENTRY + queryString);
}

function installAPI(mainWindow: BrowserWindow) {
  ipcMain.removeHandler<IEvidAPI>("showOpenFile");
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ipcMain.handle<IEvidAPI>("showOpenFile", async (_event, ...args) => {
    const openResult = await dialog.showOpenDialog(mainWindow, {
      title: "Test Open",
      buttonLabel: "Otovit",
      filters: [
        { name: "JSON", extensions: ["json"] },
        { name: "All files", extensions: ["*"] }
      ],
      properties: [
        "openFile"
      ]
    });
    return openResult.canceled ? null : openResult.filePaths[0];
  });

  ipcMain.removeHandler<IEvidAPI>("dbgLogCurrentDb");
  ipcMain.handle<IEvidAPI>("dbgLogCurrentDb", async () => {
    console.log(currentDatabase.toJSON());
  });

  ipcMain.removeHandler<IEvidAPI>("isDbModified");
  ipcMain.handle<IEvidAPI>("isDbModified", async () => {
    return currentDatabase.isModified();
  });

  ipcMain.removeHandler<IEvidAPI>("isDbFileSet");
  ipcMain.handle<IEvidAPI>("isDbFileSet", async () => {
    return currentDatabase.hasPath();
  });

  ipcMain.removeHandler<IEvidAPI>("saveDb");
  ipcMain.handle<IEvidAPI>("saveDb", async () => {
    await currentDatabase.save();
  });

  ipcMain.removeHandler<IEvidAPI>("saveDbAs");
  ipcMain.handle<IEvidAPI>("saveDbAs", async (_event, ...[filePath, password]) => {
    currentDatabase.setFile(filePath as string, password as string);
    await currentDatabase.save();
  });

  ipcMain.removeHandler<IEvidAPI>("showSaveDbDialog");
  ipcMain.handle<IEvidAPI>("showSaveDbDialog", async (_event, ...[defaultPath]) => {
    const saveResult = await dialog.showSaveDialog(mainWindow, {
      title: "Evid Databáza",
      defaultPath: defaultPath as string,
      filters: [
        { name: "Evid Database", extensions: ["evidb"] },
        { name: "All files", extensions: ["*"] }
      ],
      properties: [
        "createDirectory", "showOverwriteConfirmation"
      ]
    });

    if (!saveResult.canceled) {
      if (saveResult.filePath && !saveResult.filePath.includes(".")) {
        saveResult.filePath += ".evidb";
      }
    }

    return saveResult as FileDialogResult;
  });

  ipcMain.removeHandler<IEvidAPI>("openDb");
  ipcMain.handle<IEvidAPI>("openDb", async (_event, ...[filePath, password]) => {
    if (currentDatabase.isModified()) {
      const opts = {
        message: "Databáza nie je uložená. Naozaj otvoriť novú?",
        title: "Otvoriť Databázu?",
        type: "warning",
        buttons: ["Áno", "Nie"],
        cancelId: 1,
        noLink: true,
      };
      const result = await dialog.showMessageBox(mainWindow, opts);
      if (result.response != 0) {
        return;
      }
    }
    try {
      const db = await openDb(filePath as string, password as string);
      currentDatabase = db;
    } catch {
      const opts = {
        message: "Chyba pri čitaní databázy.",
        title: "Chyba",
        type: "error",
      };
      await dialog.showMessageBox(mainWindow, opts);
    }
  });

  ipcMain.removeHandler<IEvidAPI>("showOpenDbDialog");
  ipcMain.handle<IEvidAPI>("showOpenDbDialog", async (_event, ...[defaultPath]) => {
    const dlgResult = await dialog.showOpenDialog(mainWindow, {
      title: "Evid Databáza",
      defaultPath: defaultPath as string,
      filters: [
        { name: "Evid Database", extensions: ["evidb"] },
        { name: "All files", extensions: ["*"] }
      ],
      properties: [
        "openFile"
      ]
    });

    const openResult: FileDialogResult = { canceled: dlgResult.canceled, filePath: dlgResult.filePaths[0] };

    return openResult;
  });

  ipcMain.removeHandler<IEvidAPI>("getDbPath");
  ipcMain.handle<IEvidAPI>("getDbPath", async () => {
    return currentDatabase.getFile();
  });

  ipcMain.removeHandler<IEvidAPI>("getYears");
  ipcMain.handle<IEvidAPI>("getYears", async () => {
    return currentDatabase.getYears();
  });

  ipcMain.removeHandler<IEvidAPI>("getYearEntries");
  ipcMain.handle<IEvidAPI>("getYearEntries", async (_event, ...[yearId]) => {
    return currentDatabase.getYearEntries(yearId as number);
  });

  ipcMain.removeHandler<IEvidAPI>("changeYearEntry");
  ipcMain.handle<IEvidAPI>("changeYearEntry", async (_event, ...[yearId, entryId, entryName]) => {
    currentDatabase.changeYearEntry(yearId as number, entryId as number, entryName as string);
  });

  ipcMain.removeHandler<IEvidAPI>("newYearEntry");
  ipcMain.handle<IEvidAPI>("newYearEntry", async (_event, ...[yearId, entryType]) => {
    currentDatabase.newYearEntry(yearId as number, entryType as EntryType);
  });

  ipcMain.removeHandler<IEvidAPI>("changeEntriesOrder");
  ipcMain.handle<IEvidAPI>("changeEntriesOrder", async (_event, ...[yearId, entriesOrder]) => {
    currentDatabase.changeEntriesOrder(yearId as number, entriesOrder as IEntryOrder[]);
  });

  ipcMain.removeHandler<IEvidAPI>("getYearEntrySum");
  ipcMain.handle<IEvidAPI>("getYearEntrySum", async (_event, ...[yearId, entryId]) => {
    return currentDatabase.getYearEntrySum(yearId as number, entryId as number);
  });

  ipcMain.removeHandler<IEvidAPI>("deleteYearEntry");
  ipcMain.handle<IEvidAPI>("deleteYearEntry", async (_event, ...[yearId, entryId]) => {
    currentDatabase.deleteYearEntry(yearId as number, entryId as number);
  });

  ipcMain.removeHandler<IEvidAPI>("getYearSums");
  ipcMain.handle<IEvidAPI>("getYearSums", async (_event, ...[yearId]) => {
    return currentDatabase.getYearSums(yearId as number);
  });

  ipcMain.removeHandler<IEvidAPI>("getMonthEntries");
  ipcMain.handle<IEvidAPI>("getMonthEntries", async (_event, ...[yearId, monthId]) => {
    return currentDatabase.getMonthEntries(yearId as number, monthId as MonthId);
  });

  ipcMain.removeHandler<IEvidAPI>("incrementMonthEntry");
  ipcMain.handle<IEvidAPI>("incrementMonthEntry", async (_event, ...[yearId, monthId, entryId, value]) => {
    currentDatabase.incrementMonthEntry(yearId as number, monthId as MonthId, entryId as number, value as number);
  });

  ipcMain.removeHandler<IEvidAPI>("setMonthEntry");
  ipcMain.handle<IEvidAPI>("setMonthEntry", async (_event, ...[yearId, monthId, entryId, value]) => {
    currentDatabase.setMonthEntry(yearId as number, monthId as MonthId, entryId as number, value as number);
  });

  ipcMain.removeHandler<IEvidAPI>("printMonthReport");
  ipcMain.handle<IEvidAPI>("printMonthReport", async (_event, ...[yearId, monthId]) => {
    printReport("month", yearId as number, monthId as MonthId);
  });

  ipcMain.removeHandler<IEvidAPI>("printYearReport");
  ipcMain.handle<IEvidAPI>("printYearReport", async (_event, ...[yearId]) => {
    printReport("year", yearId as number);
  });

  ipcMain.removeHandler<IEvidAPI>("getMonthsSums");
  ipcMain.handle<IEvidAPI>("getMonthsSums", async (_event, ...[yearId]) => {
    return currentDatabase.getMonthsSums(yearId as number);
  });
}

const createWindow = async (): Promise<void> => {
  const windowSettings = await settings.get("window") as WindowSettings | null;

  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height: windowSettings?.height || 600,
    width: windowSettings?.width || 800,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools if in dev mode.
  if (isDev) {
    mainWindow.webContents.openDevTools({mode: "detach"});
  }

  mainWindow.on("ready-to-show", () => {
    installAPI(mainWindow);

    if (windowSettings?.maximized) {
      mainWindow.maximize();
    }
  });

  mainWindow.on("close", (e) => {
    if (currentDatabase.isModified()) {
      const opts = {
        message: "Databáza nie je uložená. Naozaj skončiť?",
        title: "Skončiť?",
        type: "warning",
        buttons: ["Áno", "Nie"],
        cancelId: 1,
        noLink: true,
      };
      if (dialog.showMessageBoxSync(mainWindow, opts) != 0) {
        e.preventDefault();
        return;
      }
    }

    const windowSettings: WindowSettings = {
      height: mainWindow.getBounds().height,
      width: mainWindow.getBounds().width,
      maximized: mainWindow.isMaximized()
    };

    settings.setSync("window", windowSettings);
  });
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', () => {
  // Conditionally include the dev tools installer to load React Dev Tools
  if (isDev) {
    const installExtension = devTools.default;
    installExtension(devTools.REACT_DEVELOPER_TOOLS)
      .then((name) => console.log(`Added Extension:  ${name}`))
      .catch((error) => console.log(`An error occurred: , ${error}`));
  }

  createWindow();
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
