import { app, BrowserWindow, dialog } from 'electron';
import { ipcMain } from 'electron-typescript-ipc';
import { IEntryOrder, IEntrySum, IEvidAPI } from './ui/api';
import * as devOnly from "electron-devtools-installer";
import * as settings from "electron-settings";
import { Entry, EntryType, EvidDb, MonthEntries, MonthId, monthToOrder, YearMonths } from './model';

// Conditionally include the dev tools installer to load React Dev Tools
let devTools: typeof devOnly;  
const isDev = !app.isPackaged;
if (isDev) {  
  devTools = require("electron-devtools-installer");
}

// This allows TypeScript to pick up the magic constant that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;

declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;


declare const PRINT_WINDOW_WEBPACK_ENTRY: string;

declare const PRINT_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) { // eslint-disable-line global-require
  app.quit();
}

type WindowSettings = {
  height?: number,
  width?: number,
  maximized?: boolean
}

const fakeDb: EvidDb = {
  1977: {
    entries: {
      1: {
        name: "Vyplata",
        type: "income",
        order: 1
      },
      2: {
        name: "Kreditka",
        type: "expense",
        order: 2
      },
      3: {
        name: "Vynosy",
        type: "income",
        order: 3
      },
      5: {
        name: "Potraviny",
        type: "expense",
        order: 5
      }
    },
    months: {
      jan: {
        1: 1500,
        2: 1200,
      },
      feb: {
        1: 1500,
        3: 800,
        2: 1200,
        5: 1200
      },
      mar: {},
      apr: {},
      may: {},
      jun: {},
      jul: {},
      aug: {},
      sep: {},
      oct: {},
      nov: {},
      dec: {}
    }
  }
}

let fakeDbModified = false;

function entrySum(yearMonths: YearMonths, entryId: number) {
    return Object.entries(yearMonths)
      .map(([, month]) => month[entryId] || 0)
      .reduce((partialSum, a) => partialSum + a, 0);
}

const monthReportPrintOptions: Electron.WebContentsPrintOptions = {
  margins: {
    marginType: "printableArea"
  },
  printBackground: false,
  landscape: false,
  pageSize: "A4"
};

const yearReportPrintOptions: Electron.WebContentsPrintOptions = {
  margins: {
    marginType: "printableArea"
  },
  printBackground: false,
  landscape: true,
  pageSize: "A4"
};

function printReport(type: "year" | "month", yearId: number, monthId?: MonthId) {
  const printWindow = new BrowserWindow({
    height: 1200,
    width: 1600,
    show: false,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: PRINT_WINDOW_PRELOAD_WEBPACK_ENTRY
    },
  });

  console.log("printReport(" + type + ")");

  ipcMain.removeHandler<IEvidAPI>("contentRendered");
  ipcMain.handle<IEvidAPI>("contentRendered", async () => {
    printWindow.webContents.print((type == "year" ? yearReportPrintOptions : monthReportPrintOptions), () => printWindow.close());
  });

  printWindow.on("close", () => {
    ipcMain.removeHandler<IEvidAPI>("contentRendered");
  });

  let queryString = "?type=" + type + "&yearId=" + yearId;
  if (type == "month") {
    queryString += "&monthId=" + monthId;
  }

  // and load the index.html of the app.
  printWindow.loadURL(PRINT_WINDOW_WEBPACK_ENTRY + queryString);
}

function installAPI(mainWindow: BrowserWindow) {
  ipcMain.removeHandler<IEvidAPI>("showOpenFile");
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ipcMain.handle<IEvidAPI>("showOpenFile", async (_event, ...args) => {
    const openResult = await dialog.showOpenDialog(mainWindow, {
      title: "Test Open",
      buttonLabel: "Otovit",
      filters: [
        { name: "JSON", extensions: ["json"] },
        { name: "All files", extensions: ["*"]}
      ],
      properties: [
        "openFile"
      ]
    });
    return openResult.canceled ? null : openResult.filePaths[0];
  });

  ipcMain.removeHandler<IEvidAPI>("dbgLogCurrentDb");
  ipcMain.handle<IEvidAPI>("dbgLogCurrentDb", async () => {
    console.log(JSON.stringify(fakeDb, null, 2));
  });

  ipcMain.removeHandler<IEvidAPI>("isDbModified");
  ipcMain.handle<IEvidAPI>("isDbModified", async () => {
    return fakeDbModified;
  });

  ipcMain.removeHandler<IEvidAPI>("getYears");
  ipcMain.handle<IEvidAPI>("getYears", async () => {
    return Object.entries(fakeDb).map(([key]) => Number(key));
  });

  ipcMain.removeHandler<IEvidAPI>("getYears");
  ipcMain.handle<IEvidAPI>("getYears", async () => {
    return Object.entries(fakeDb).map(([key]) => Number(key));
  });

  ipcMain.removeHandler<IEvidAPI>("getYearEntries");
  ipcMain.handle<IEvidAPI>("getYearEntries", async (_event, ...[yearId]) => {
    return fakeDb[yearId as number].entries;
  });

  ipcMain.removeHandler<IEvidAPI>("changeYearEntry");
  ipcMain.handle<IEvidAPI>("changeYearEntry", async (_event, ...[yearId, entryId, entryName]) => {
    fakeDb[yearId as number].entries[entryId as number].name = entryName as string;
    fakeDbModified = true;
  });

  ipcMain.removeHandler<IEvidAPI>("newYearEntry");
  ipcMain.handle<IEvidAPI>("newYearEntry", async (_event, ...[yearId, entryType]) => {
    const evidYear = fakeDb[yearId as number];
    const newEntryId = 1 + Object.entries(evidYear.entries)
            .map(([entryId]) => Number(entryId))
            .reduce((a, b) => Math.max(a, b), 0);
    const newEntry: Entry = {type: entryType as EntryType, name: "Nová položka", order: newEntryId};
    evidYear.entries[newEntryId] = newEntry;
    fakeDbModified = true;
  });

  ipcMain.removeHandler<IEvidAPI>("changeEntriesOrder");
  ipcMain.handle<IEvidAPI>("changeEntriesOrder", async (_event, ...[yearId, entriesOrder]) => {
    const yearEntries = fakeDb[yearId as number].entries;
    (entriesOrder as IEntryOrder[]).forEach((entryOrder) => yearEntries[entryOrder.entryId].order = entryOrder.order);
    fakeDbModified = true;
  });

  ipcMain.removeHandler<IEvidAPI>("getYearEntrySum");
  ipcMain.handle<IEvidAPI>("getYearEntrySum", async (_event, ...[yearId, entryId]) => {
    return entrySum(fakeDb[yearId as number].months, entryId as number);
  });

  ipcMain.removeHandler<IEvidAPI>("deleteYearEntry");
  ipcMain.handle<IEvidAPI>("deleteYearEntry", async (_event, ...[yearId, entryId]) => {
    const yearEntries = fakeDb[yearId as number].entries;
    delete yearEntries[entryId as number];
    const yearMonths = fakeDb[yearId as number].months;
    Object.entries(yearMonths).forEach(([, month]) => delete month[entryId as number]);
    fakeDbModified = true;
  });

  ipcMain.removeHandler<IEvidAPI>("getYearSums");
  ipcMain.handle<IEvidAPI>("getYearSums", async (_event, ...[yearId]) => {
    const yearEntries = fakeDb[yearId as number].entries;
    return Object.entries(yearEntries)
      .map(([entryId, entry]) => {
        return {entryId: Number(entryId), entry, sum: entrySum(fakeDb[yearId as number].months, Number(entryId))};
      });
  });

  ipcMain.removeHandler<IEvidAPI>("getMonthEntries");
  ipcMain.handle<IEvidAPI>("getMonthEntries", async (_event, ...[yearId, monthId]) => {
    return fakeDb[yearId as number].months[monthId as MonthId];
  });

  ipcMain.removeHandler<IEvidAPI>("incrementMonthEntry");
  ipcMain.handle<IEvidAPI>("incrementMonthEntry", async (_event, ...[yearId, monthId, entryId, value]) => {
    const monthEntries = fakeDb[yearId as number].months[monthId as MonthId];
    if (monthEntries[entryId as number]) {
      monthEntries[entryId as number] += value;
    } else {
      monthEntries[entryId as number] = value;
    }
    fakeDbModified = true;
  });

  ipcMain.removeHandler<IEvidAPI>("setMonthEntry");
  ipcMain.handle<IEvidAPI>("setMonthEntry", async (_event, ...[yearId, monthId, entryId, value]) => {
    fakeDb[yearId as number].months[monthId as MonthId][entryId as number] = value;
    fakeDbModified = true;
  });

  ipcMain.removeHandler<IEvidAPI>("printMonthReport");
  ipcMain.handle<IEvidAPI>("printMonthReport", async (_event, ...[yearId, monthId]) => {
    printReport("month", yearId as number, monthId as MonthId);
  });

  ipcMain.removeHandler<IEvidAPI>("printYearReport");
  ipcMain.handle<IEvidAPI>("printYearReport", async (_event, ...[yearId]) => {
    printReport("year", yearId as number);
  });

  ipcMain.removeHandler<IEvidAPI>("getMonthsSums");
  ipcMain.handle<IEvidAPI>("getMonthsSums", async (_event, ...[yearId]) => {
    function monthEntriesToSums(monthId: MonthId, monthEntries: MonthEntries) {
      return Object.entries(monthEntries)
      .map(([entryIdStr, value]) => {
        const entryId = Number(entryIdStr);
        return {entryId, entry: entries[entryId], sum: value};
      })
      .sort((a, b) => {
        if (a.entry.type == b.entry.type) {
          return a.entry.order - b.entry.order;
        } else {
            if (a.entry.type == "expense") {
                return -1;
            } else {
                return 1;
            }
        }
      });
    }

    function entriesSum(sums: IEntrySum[], entryType: EntryType) {
      return sums
            .filter((row) => row.entry.type == entryType)
            .map((row) => row.sum)
            .reduce((totalSum, a) => totalSum + a, 0);
    }
    
    const entries = fakeDb[yearId as number].entries;
    const sums = Object.entries(fakeDb[yearId as number].months)
      .map(([monthId, monthEntries]) => {
        const monthSums = monthEntriesToSums(monthId as MonthId, monthEntries);
        const totalIncome = entriesSum(monthSums, "income");
        const totalExpense = entriesSum(monthSums, "expense");

        return {
              monthId: monthId as MonthId,
              sums: monthSums,
              totalIncome,
              totalExpense
        };
      })
      .sort((a, b) => monthToOrder(a.monthId) - monthToOrder(b.monthId));
    return sums;
  });
}

const createWindow = async (): Promise<void> => {
  const windowSettings = await settings.get("window") as WindowSettings | null;

  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height: windowSettings?.height || 600,
    width: windowSettings?.width || 800,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools if in dev mode.
  if (isDev) {
    mainWindow.webContents.openDevTools({mode: "detach"});
  }

  mainWindow.on("ready-to-show", () => {
    installAPI(mainWindow);

    if (windowSettings?.maximized) {
      mainWindow.maximize();
    }
  });

  mainWindow.on("close", () => {
    const windowSettings: WindowSettings = {
      height: mainWindow.getBounds().height,
      width: mainWindow.getBounds().width,
      maximized: mainWindow.isMaximized()
    };

    settings.setSync("window", windowSettings);
  });
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', () => {
  // Conditionally include the dev tools installer to load React Dev Tools
  if (isDev) {
    const installExtension = devTools.default;
    installExtension(devTools.REACT_DEVELOPER_TOOLS)
      .then((name) => console.log(`Added Extension:  ${name}`))
      .catch((error) => console.log(`An error occurred: , ${error}`));
  }

  createWindow();
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
